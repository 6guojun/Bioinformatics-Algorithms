#Finds most probable kmer based on profile
def prof_most_prob(string,k,a,c,g,t):
    kmers_probs = []
    probs = []
    for i in range(0,len(string)-k+1):
        kmer = string[i:i+k]
        prob = 1
        pos = 0
        for nt in kmer:
            if nt == "A":
                prob = prob * a[pos]
            elif nt == "C":
                prob = prob * c[pos]
            elif nt == "G":
                prob = prob * g[pos]
            elif nt == "T":
                prob = prob * t[pos]
            pos += 1    
        kmers_probs.append({kmer:prob})
        probs.append(prob)
    for pair in kmers_probs:
        for kmer in pair:
            if pair[kmer] == max(probs):
                return kmer

#Scores a set of kmers based on consensus scoring method
def score(list,k):
    AA = [0] * k
    CC = [0] * k
    GG = [0] * k
    TT = [0] * k
    x = 0
    y = 0
    consensus = ''
    
    for kmer in list:
        for i in range(0,len(kmer)):
            if kmer[i] == "A":
                AA[i] += 1
            elif kmer[i] == "C":
                CC[i] += 1
            elif kmer[i] == "G":
                GG[i] += 1
            elif kmer[i] == "T":
                TT[i] += 1
                
    for i in range(0,k):
        if AA[i] == max(AA[i],CC[i],GG[i],TT[i]):
            consensus = consensus + "A"
        elif CC[i] == max(AA[i],CC[i],GG[i],TT[i]):
            consensus = consensus + "C"
        elif GG[i] == max(AA[i],CC[i],GG[i],TT[i]):
            consensus = consensus + "G"
        elif TT[i] == max(AA[i],CC[i],GG[i],TT[i]):
            consensus = consensus + "T"
    
    score = 0
    pos = 0
    for nt in consensus:
        for kmer in list:
            if kmer[pos] == nt:
                pass
            else:
                score += 1
        pos += 1
    return score
    
#################################  

k = 15 #kmer length
t = 20 #number of sequences to search

DNA = [
'CACAGGTATAACATATCCCAGTTGTGAATGGAGCTGACCTTATCCAGCCCATGCCTGATCCGGGAACAACCTCCTAGCTCGTGCTAGTAAGTTCGGTTTTGGTCACAATCTTTCTTATACCGTGCACACGTGATCACCGAACGTATTACAACAGTTACCGATAAGTCGCGGGCTACCGACACGAGGATAGCCAAGACCTTTTGCGCAATCACTCTAAGTTCTACTCCAAGCCCTAGACCAGAGACTACGCGTATGGTGATATTATCAGGGTTTCAAGGTTTATCGCACGACCATGACCGAGAAGGTGCCCACAGGTATAACATA',
'TCCCAGTTGTGAATGGAGCTGACCTTATCCAGCCCATGCCTGATCCGGGAACAACCTCCTAGCTCGTGCTAGTAAGTTCGGTTTTGGTCACAATCTTTCTTATACCGTGCACACGTGATCACCGAACGTATTACAACAGTTACCGATAAGTCGCGGGCTACCGACACGAGGATAGCCAAGACCTTTTGCGCAATCACTCTAAGTTCTACTCCAAGCCCTAGACCAGAGACTACGCGTATGGTGATATTATCAGGGTTTCATCAGCCAACGGTGCAAGGTTTATCGCACGACCATGACCGAGAAGGTGCCCACAGGTATAACATA',
'CGGGCGTGGGACGACCCAGCTTCAATTAGACCGGGTATGGGTATATGTATGATACTGATCGTAAATTATTTGAGGGCAAACAAGAGCTCGAATGGTAAAGGGCATGAATGTGCGAGATGGTATTCGTCTGCTAAGTAGAAAGTCGAGACGTGACGAGCGTGCGCCAAATATGAGCCAGTTGTGTAGGTTATGCGATCATGGTCCGTCAAGGGGGAGGATTGTCCGATCTCTAAGGATCCACTGACGGGCCTGTATCCCCAACGGTGAGAAACAGGGTAGAGCAATATCAGCCAGCTAGGGTGACCTAATTTTCGGAGCCTGCCC',
'TGACTATATCCCACCGCGGCAGGGGCCTCGCACCGGTCTAGTAAGCAACCTGTGGTCTTCATCAGTCCTTGCCCAAGCGTAGTGTACAAGGGCCAATCTCGCGTATGAACCACCGCAATGCGCAGGGGATAGGATAGCGGTTCTCGTGCACTACTTGACATAATCATCCACTCCACTCATACAAACCACCACTCCATCTTTTTTACCCTGACCGCTAGACATGTAACCGTGGCAGTGATGTTGACTGCGTTCGATGTCTTGCAGCCGCGACGATGTACGGCCAAGCTCTTATGGGAACAATTCCCCAACGGACGGAACACTCTA',
'TTCCCTTGCGTGAGGCTGAACGACAATTGCGCGCACAATAGCACCTTGGGGCTCATAAATCCTCAAAAGTCTCGGTTCGGGGTTAAACTAACTTTGGTTTGCCAACGTACCGGTTGGCTGATCGCCTAATGTACGTTAAACCGCATATAGATTAAGAGACGAAATTTTAACCATTCATGAACGGTGACGGCGACTGGCAGCTTGGAGATACTTAGTGATGGCCGTGTCCTTTTCCGGACTTTTTCGGGAAGAACGTTCTGATACAGGGTACTACCGCTATCGATCTGAGATGGTCGCACCGGTGTCGAATACCTTGGCAGTAAG',
'CCCGATGCCCCAACTACGACACTCGGCATGCCAAGAGCGTCATTCCCGCCCGGTGTGAGAACCTAGTCTTTTTAACACTCCATAGTCAGATTACTTTCTGTACTAAAGACTCGCAAATTTCATGGCTCGTTCTGCTATGCTGCGCCTGTCTATGATAATTTGAATGAAGGGCAGGGACACAAGTGCCTTTACGACTAGCACATTCGACGCACTGTCTAGAACATGCTTTTAGAATCATCATTCTCTCTGTAGCCGAATTCTGCTCGCGCAAGCGACACGTTGCAGGACGCCCGGCACGGAAACCCTCTCGTCCAGGCTGCCCTG',
'CAGAAAAGATATCCGCAGCGCAGTCGCAGGAGCCTAGCACATTGATCAACGGTGCGTTAAGGAGATCAGTTGGACTCCTCATCTGGATAGGCTAATAGCGTGGCGATTGTCGGTCTGAGTCAACCATCCCGAACATTCGGAGGTGCATTGCGAGTTTGGTGGCAAGCGAGGGGGATCCTGGGAATTTTCGGGGAGGAACACGGCAAGTTTATTCTTGGTTACGCACCCACCCTAATCGTAATTGAACTATCCCGATTTTTACCAGATTCGGTACCAGATAATCTAGGAATTTCCGTGACACAGCCAACTACGATGCATGGACAC',
'CTTAGCGACGTTTAAGACCAGTTCCGAGTATGCCCAGTAACATCGGGGCCGGCCAAGGGTCGCCATGGAAACGGTATGCGGTATACCGGGCTGTGATGACATTCCCCCCTGGTGAGTTTTTTGCTACATCGTGTCTTAGCTAGGGTACCTTTGGCAGCCGGCAGGACGACCCGTACGGAATGTCCCCTATGCGCAAATGTGTAGGGCAAAGGTTCCGTTAACATCAGAAATACCGACCGTCATTATAAACACTTCATCCTGCGCCGCATGTCGGTGTAAGATTGTAACTCTAGCTGAGGGTTCACGCGCCCTCACCAATGCGTG',
'CGATCACGCCTCATGAAGGCTAGGGAAGCCCGGAGACCACGTAGAGTATATTTCACAGGGTTAATCCGTGGGTGAAAAAGAGTAATCCAGCATTTGTCACGGCCCAAGTATACGGGTCAATTTATACGTTCTACGTGCTTGGAGTTCTTAGAGTTCAAGATGGTGACGCCGCCATTTGTCAACGGTGCAGATAAGAACACGCTCGGGCTTTTACCACGTTAGCCTTCTGTCAGAGCCCACCAATGAAGATCCAGATGATCTATTTGATTTTCGAAAGAGAAGGTTTTTTACGCGTACTCACACGGGAATCCTGGTATAAACGCA',
'CATGTCGTTAGTTGCAGCGCTGTAGTCTTCAGTTGCCGGGATATGTGTTCCGGTCTTCGAGGCCAAACTCTAGGTGTGATGCACGTTAAAGACAAAAGTCTTCCCAGGAGTGAGGGGAGCTGAACTTACGAGCTTGTGGGCTCGCTTCCCATTCCCCAACGTGATCGGACTATTCCATTCCGTGCAAATGAATGCGCACATTGCGGAGCTAGTTTCTAACGAGAGGGTCGCCTGCTATGTAGAACTGTCTCTGACTCATATGGTAGTCTTGCCTTCGGGTGACGAGCAAAGTCGCCTTAAAGGTTCAACGGGTTAGTCAATCCC',
'CACAGATCTGTGCCTCACGAGAAGGATACTAACTACGAATTAACGAAACCAGACTTTCATAGTGGGTCAAATGTCCCCTCAAGTAAGAAGATTCAGTTTTGCCTACAAGGAAGGCCCCGTTTCGACGCCCCCACGGTTCTAGGTGGTCAACGCTAGACCGCATGCAAGCACTTACACTCTGGGTAGACCAAGTATCCTGTAGTCACCGAGCATGTGGATCTGCCTACTCCAGGACATTCCCCAAAACTGCGCTAGTGAGGCATAGGTGATTGAGGTACTGATCTGACGTTTAGATCCTTGCGGAACAGCTAGGGTCTATTACGA',
'TACCATATACATCACTTGTCGATCACCCCCTACCTCACCCCCCCCAACGGTGGTCATTTAGCGTGTTCTCAGCGTGACTTTTGTGGTAGGTCGGCACACACAGCTGGTTTAGCGTTGTCCAGGTAGGTCTGACCCTCTACCTAGACGGTCACATAAAACTAAAACTGCGCCACCTAAAAGACCGATAGAAGAATATGGACACCTACGTGACTGTAGCTGTCTACTCACAGTACAAATACCAGTCCTCGTCTCTACCCATGAGACAACCCAGCTCCTTTAAATCAGGACGTAAGCTGAAAGTTGCGTACAGCTACGGAGCGGCGC',
'TAGTGATAGACTAATGCGTACAGCGAGCCCGATTTAGGAATACAAGGAGGGCGTTGCCGGCCTGGGGTCTGTAACAGCAGAGACAGACTTATGTAGAGTAGTACGGAAGGATGCCCCCGGAGTATGCCGTGGGAGGGGAGTCTGTACGGGCTTCCCCAACGGTTTGAAGGCGACAGACTCCGCAGCAGAACTGAGGAAAACCCCGCTCAGATTGGGGCCGTTGGAGAGAGGCTGCAGAGCAATGTGTCAAATAACAGGTACCTCTACTGCCGAAAGACCAGCTTAATCCTTGTGTACAAAGCTCGGTTTAATGTGGGGAAATTC',
'AGGTAATATTTTGGCCTTATGTCTCGTTGAATACGAACCTGTGGGAAGGATACCGCCGCGGCACAGTGTCTAGCGGCCAGTTGTTTCGCGACGCGCTAATTTGCTTTCCAACCTTCTTTAGTAAATTCGATCTGCCCGCATTCCCCAGTAGTGGACTGAAACTCTGCGAGCCAGCTTGGGCATTTGTTGCGAGCGCCGCATTAGCCTTTACGCGGGTACCTCGCTCAAACGGAGTGGCGTAGAAGAACTCGTCGCTCTGAGTACGTCCATTGTGTGAGCGTTTTACTGGAATCCCGGGGACGGTGTCCCAGCGAGGTGAGGGCA',
'GGTTCGTGCGGTTCGGCTGAACCTCCCCGAACCTAAATGTAGCCAAGAGGATTTCGTCAACGCCCAACGGTGAATCCCCCTCATCAGCTTAGATTCCCTAAATGGCGTAAGTTGGCGCCTTTCCCGAAAACCCGCCAATAAACTTCTCCGTAACCATGAGACGACCCGAAGGTGTATGATGGGAGCCATGTTCAAGTTACACATATGTTGCGGCTGAGTTAGGGGGAAGCCACCTACTAGGATTACGGAATGGTCGCCTTAACAGGCGGGTAGTGTGAGGACTTCACCTTATCACTCTTGAAGGGCCATTGCGCTACATCACGT',
'TACAAGTGATATGTATAGATAACGGCTTCACAACGAACGCCCGCTCCCCCGCGCGATAGAGGGTGACGATTAATACGACTGGGGACGGATGACCCGTCCACCACGAATCAGCGGACTTTAGTCTCAATTGTCAGTGTGTGTAGTACGAAGCCGGGCTCTGAAAAGTTCAGTAAATCGGGCCCCGAAGCTTGTCATAATAGCAGCCCATTGACCATTCGTTAACGGTGGGCGTTTCGCAAGCAGGACAAGGTCCCACTACATTAATAAGCACATGACCCATGAAACACACGGTACTATCAGTTTGGTTAAGGCTTCACTTGAGTG',
'CTAGTGATTATAAGGCAGCTGTCACCAGATTGTCCGTTGGAATATGGTTAAGTCGATGGGCACCTCCCTTGCGATCATTAATGGAGCGTCGAAATTAGTCGAAGAAGCACCTCTGCATCGAGCTCTATTCGGCGTGATTGCGTAACCATATATCATTCCCCAACAACGAGAAGCGCGCAGCTGCCACATTGGAGCCATGTAACGGTAGGGATCCGGTAATAGCGCATGTTGGCATACTAACAGTCTCTTTGGTTCTTGACACGACCTGAACACAGCGGGCATACAATGGTTGGCGTCCCTCATAGTCTCATTCCGGCCCCATGG',
'TCTTGTTAGACTAACCTAGCATACCTTCTGAAAGCCTAAGTCTCAGCCGTCAGGTTTCAAAGAGCTCATACGACCGAGGCTGGTCAACAAACATTACATTGGACAAGCTTGGTGCCTCACATGGATCTCTGCTCAACAACTACGTAACGCGCAATCATGCGGACACGTAGCTATAGGTAACTGGGAAGGTCGCGCGTGGTGTCTATGACCTCTTCGCCGTGTCTCAGCCGGTAGAGACGTCATTCCGGTACGGTGCTCGCTAGTAGGGCGGGACCGTCGCGGACATCTTCCATCCCGATCCTATCAGAGTATGGCGTTCGTGTA',
'GGGATTGTCATAAAGCTTGGTGGCCGTGACACGCGACTTGTACTCGTAGGCAACAAGTACCGGTGCGAATCCTGCCGCACGCTAGCTTCGGCCTTCAATTAGTCATGTGCCAACGGTGGCCTTTCGAATGCGCGTTCTTACTAAACTATTCTACCCTTACTAACAAATGTTTCGATAAGGCTCTCAATAGCACAGGCAGGTTGACTGCTAGACAGGACTTCCAACTGCTGGACCGTTGCCTCGGGGCTCTATATGGCGCATGTGCGTTATTGAGGATCGGTGTGTTTGCCCTATCTGCTGAGAAGTCGCGGTACCCCCGGTGCA',
'TAAAGTAGTTCACAGGATAGGATAGAACGTACTTAGCGCAGGGTCATATTGTACGAGATGATATAAGTGTAAATAGCGTCCGCAGGAAAAAGAGAGCATTCTCCGACTCCCTGGTCCCAATAAATAACTCCTCGGTTGTATCACACGGCCGCTACCGATGGAGTGCATAGAGCTTTTTGCCCATTCCTTGACGGTGCCTGGTAAGAGCGATTGGCCCTTCCTAACGGACCTCTAATCGTTGCAGGACGAAAGAGTCGATACGGCGCTGATTCCCCCCAGGCTCAGCGCTACTCCCATTGGAGGAGGTGACTACTCTGTGTACGC'
]

#Winning list
winner = []
for seq in DNA:
    from random import randint
    i = randint(0,len(seq)-k)
    winner.append(seq[i:i+k])
   
run = 0
while run < 500:
    
    #Final list each run
    best_kmers = []
     
    #Randomly select k-mers
    from random import randint
    random_kmers = []
    for seq in DNA:
        i = randint(0,len(seq)-k)
        random_kmers.append(seq[i:i+k])
        best_kmers.append(seq[i:i+k])

    #Pseudocounts
    A = [1.0] * k
    C = [1.0] * k
    G = [1.0] * k
    T = [1.0] * k
    #Probabilities
    a = [0.0] * k
    c = [0.0] * k
    g = [0.0] * k
    t = [0.0] * k
    Total = [0.0] * k
    
    for kmer in random_kmers:
        pos = 0
        for nt in kmer:
            if nt == "A":
                A[pos] += 1
            elif nt == "C":
                C[pos] += 1
            elif nt == "G":
                G[pos] += 1
            elif nt == "T":
                T[pos] += 1
            pos += 1  

    #Profile
    for i in range(0,k):
        Total[i] = A[i]+C[i]+G[i]+T[i]
        a[i] = A[i]/Total[i]
        c[i] = C[i]/Total[i]
        g[i] = G[i]/Total[i]
        t[i] = T[i]/Total[i]
    
    randomize = 0
    count = 0
    challenging_best_kmers = []
    while count < 5:
        count += 1
        if randomize == 0: 
            challenging_best_kmers = []
            for seq in DNA:
                challenging_best_kmers.append(prof_most_prob(seq,k,a,c,g,t))
        
        elif randomize == 1:
            challenging_best_kmers = []
            for seq in DNA:
                i = randint(0,len(seq)-k)
                challenging_best_kmers.append(seq[i:i+k])
        
        #Scoring
        if score(challenging_best_kmers,k) < score(best_kmers,k):
            best_kmers = challenging_best_kmers
            randomize = 0
        
            #Reprofile
            A = [1.0] * k
            C = [1.0] * k
            G = [1.0] * k
            T = [1.0] * k
            a = [0.0] * k
            c = [0.0] * k
            g = [0.0] * k
            t = [0.0] * k
            Total = [0.0] * k
    
            for kmer in best_kmers:
                pos = 0
                for nt in kmer:
                    if nt == "A":
                        A[pos] += 1
                    elif nt == "C":
                        C[pos] += 1
                    elif nt == "G":
                        G[pos] += 1
                    elif nt == "T":
                        T[pos] += 1
                    pos += 1  
        
            for i in range(0,k):
                Total[i] = A[i]+C[i]+G[i]+T[i]
                a[i] = A[i]/Total[i]
                c[i] = C[i]/Total[i]
                g[i] = G[i]/Total[i]
                t[i] = T[i]/Total[i]
    
        else:
            randomize = 1
    
    if score(best_kmers,k) < score(winner,k):
        winner = best_kmers
    
    run += 1
    
print 'WINNER'
for kmer in winner:
    print kmer
print score(winner,k)

'''
Output
